-------------- LAB #2 ------------------
-- File: answers-lab2.txt
-- Author: Tu Lam
-- Date: April 22nd, 2021
----------------------------------------


--------------------------------------------------------------------------------------

Question #1: Assuming that the following JOS kernel code is correct, what type should 
variable x have, uintptr_t or physaddr_t?

  mystery_t x;
  char* value = return_a_pointer();
  *value = 10;
  x = (mystery_t) value;

Answer: The variable x should have is the uintptr_t. It's define as "JOS kernel 
can dereference a uintptr_t by first casting it to a pointer type" (Lab2) as that
what it's doing at "*value = 10" before assign to x. And the "kernel can’t sensibly 
dereference a physical address". So leaving with uintptr_t as our answer.

---------------------------------------------------------------------------------------

Question #2:  What entries (rows) in the page directory have been filled in at this point? 
What addresses do they map and where do they point? In other words, fill out this table 
as much as possible:

Answer: 
______________________________________________________________________________________
|____Entry______|________Base Virtual Address_____|______Points to (Logically)_______|
|_____1023______|___________0xffc00000____________|Page table for top 4MB of Phys Mem| 
|_____1022______|___________0xff800000____________|Page table for 2nd to top 4MB_____|
|_____960_______|___________0xf0000000____________|KERNBASE (Page table starting 4MB)|   
|_____959_______|___________0xefc00000____________|MMIOLIM___________________________|
|_____958_______|___________0xef800000____________|ULIM, MMIOBASE (Mem Map I/O)______|
|_____957_______|___________0xef400000____________|UVPT (Current Page Table)_________|
|_____956_______|___________0xef000000____________|UPAGES (Pages Read-Only)__________|
|______2________|___________0x00800000____________|UTEXT_____________________________|
|______1________|___________0x00400000____________|UTEMP_____________________________|
|______0________|___________0x00000000____________|Empty Memory______________________|

---------------------------------------------------------------------------------------

Question #3: We have placed the kernel and user environment in the same address space. 
Why will user programs not be able to read or write the kernel’s memory? What specific 
mechanisms protect the kernel memory?

Answer: User will not be able to read/write in the kernel's memory due to the permission
flags such as PTE_W where it is writable and the PTE_U where user can read it, but since
we place the kernel into the pages, it is only readable to user. The specific mechanism
protecting the kernel memory is through the Current Privilege Level (CPL), the low 2 bits 
of CS. CPL = 0 is privileged O/S, CPL = 3 is the user. This is use to detect the current
mode and see if we can write or not using the vma (virtual memory address).

---------------------------------------------------------------------------------------

Question #4: What is the maximum amount of physical memory that this operating system can
support? Why?

Answer: From the "kern/pmap.h", we can mapped up to 256MB of physical memory that the 
operating system can support. The reason is that we only have the limit from address
0xf0000000 to 0xffffffff which is only 256MB and there's no way to reference something 
that is greater than 4GB.

---------------------------------------------------------------------------------------

Question #5: How much space overhead is there for managing memory, if we actually had the 
maximum amount of physical memory? How is this overhead broken down?

Answer: A bit over 4MB for space overhead. The overhead is broken down to there is 1024
(4096 / 4 = 1024) page tables and 1 page directory (4096 bytes / 4KB). So we have:

    4096 + (4096 * 1024) = ~4MB

---------------------------------------------------------------------------------------

Question #6: Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately 
after we turn on paging, EIP is still a low number (a little over 1MB). At what point do 
we transition to running at an EIP above KERNBASE? What makes it possible for us to 
continue executing at a low EIP between when we enable paging and when we 
begin running at an EIP above KERNBASE? Why is this transition necessary?

Answer: Revisit the page table setup in kern/entry.S & kern/entrypgdir.c, we transition
to running at an EIP above KERNBASE when we jump into the "relocated" label in entry.S. It 
is possible for us to continue executing at a low EIP between enable paging as it is mapping
a copy to PA (physical address) and not a move to VA (virtual address) or it fail. The transition
is necessary as we have more execution to do to jump above BASEKERN after page is enabled.

---------------------------------------------------------------------------------------